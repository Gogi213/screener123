# ISSUE-001: Критическая ошибка синхронизации данных в дашборде `charts`

**Дата:** 2025-11-04
**Статус:** 
**Проект:** `charts`, `analyzer`

## 1. Описание проблемы

Пользователи наблюдали необъяснимые и устойчивые расхождения на графиках спреда (соотношения `bid/bid`), отображаемых в дашборде `charts`. Графики показывали сильные отклонения от среднего, которые не соответствовали результатам, полученным от основного аналитического скрипта `analyzer`. Это создавало ложное впечатление о наличии крупных арбитражных возможностей там, где их на самом деле не было.

Возникло подозрение на наличие фундаментальной логической ошибки в коде, а не на реальную рыночную аномалию.

## 2. Процесс анализа

Для выявления корневой причины был применен метод последовательного анализа (`sequential thinking`).

### Шаг 1: Формулирование гипотезы

Основная гипотеза заключалась в том, что проблема кроется в **механизме синхронизации временных рядов**. При работе с несколькими источниками данных (в данном случае, две разные биржи), некорректное сопоставление временных меток является наиболее частой причиной возникновения "фантомных" артефактов в данных.

### Шаг 2: Исследование кода

Были проанализированы два ключевых файла, отвечающих за обработку и синхронизацию данных:
1.  `analyzer/run_all_ultra.py` — основной скрипт для расчета статистики.
2.  `charts/server.py` — сервер для визуализации данных.

В обоих файлах для объединения данных с двух бирж используется функция `join_asof` из библиотеки Polars. Однако, при детальном рассмотрении была обнаружена **критическая разница в её использовании**.

-   **`analyzer/run_all_ultra.py`**:
    ```python
    joined = data1.rename(...).join_asof(data2.rename(...), on='timestamp')
    ```
    Здесь используется стратегия `join_asof` **по умолчанию**, которая является `strategy='backward'`. Это означает, что для каждой временной метки `T` из набора данных `A` ищется последняя по времени метка из набора `B`, которая произошла **до или в тот же момент времени `T`**. Это корректно симулирует реальные торговые условия, где мы можем реагировать только на уже поступившую информацию.

-   **`charts/server.py`** (до исправления):
    ```python
    merged_df = df_a.join_asof(df_b, on="timestamp", strategy="nearest")
    ```
    Здесь была явно указана `strategy='nearest'`. Эта стратегия для каждой метки `T` из набора `A` ищет **ближайшую по времени** метку из набора `B`, независимо от того, находится ли она в прошлом или в **будущем**.

### Шаг 3: Выявление корневой причины

Использование `strategy='nearest'` в `charts/server.py` и является **фундаментальной логической ошибкой**.

Это приводило к **"заглядыванию в будущее" (look-ahead bias)**. Сервер визуализации мог сопоставить цену с биржи `A` в момент времени `T` с ценой на бирже `B` в момент `T + dt`, если эта точка была ближе, чем точка в момент `T - dt`.

**Пример:**
- Цена на Бирже А в `10:00:01` - $100.
- Цена на Бирже Б в `10:00:00` - $100.
- Цена на Бирже Б в `10:00:02` - $101.

При использовании `strategy='nearest'`, цена $100 в `10:00:01` с биржи А будет сопоставлена с ценой $101 в `10:00:02` с биржи Б, так как временная разница (`1с`) меньше, чем с предыдущей точкой. Это создаст на графике искусственный спред в 1%, которого в реальности в момент `10:00:01` не существовало.

Именно этот эффект и приводил к появлению "фантомных" расхождений на графиках.