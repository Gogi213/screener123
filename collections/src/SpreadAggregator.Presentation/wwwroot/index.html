<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High-Performance Spread Dashboard</title>
    <link rel="stylesheet" href="https://unpkg.com/uplot@1.6.26/dist/uPlot.min.css">
    <style>
        body { font-family: sans-serif; padding: 1em; background-color: #1a1a1a; color: #eee; }
        h1 { text-align: center; }
        #dashboard { display: grid; grid-template-columns: 1fr; gap: 15px; }
        .chart-container { border: 1px solid #444; padding: 10px; background-color: #2a2a2a; border-radius: 5px; }
        .chart-container h2 { margin-top: 0; font-size: 1.1em; text-align: center; }
        .chart-wrapper { width: 100%; height: 450px; }
        #controls button {
            padding: 8px 16px;
            font-size: 1em;
            cursor: pointer;
            background-color: #333;
            color: #eee;
            border: 1px solid #555;
            border-radius: 4px;
            margin: 0 5px;
        }
        #controls button:hover {
            background-color: #444;
        }
    </style>
</head>
<body>
    <h1>High-Performance Spread Dashboard</h1>
    <div id="controls" style="text-align: center; margin-bottom: 1em;">
        <button onclick="loadHttpStream('http://127.0.0.1:5000/api/dashboard_data')">Load Historical Analysis</button>
        <button onclick="connectWebSocket()">Load Real-time Window</button>
    </div>
    <div id="status">Select a data source to load the dashboard.</div>
    <div id="dashboard"></div>

    <script src="https://unpkg.com/uplot@1.6.26/dist/uPlot.iife.min.js"></script>

    <script>
        let chartInstances = new Map();
        let activeSocket = null;

        function getChartKey(chartData) {
            return `${chartData.symbol}-${chartData.exchange1}-${chartData.exchange2}`;
        }

        function renderOrUpdateChart(chartData) {
            // Robust property access (handle camelCase and PascalCase)
            const symbol = chartData.symbol || chartData.Symbol || "Unknown";
            const ex1 = chartData.exchange1 || chartData.Exchange1 || "Ex1";
            const ex2 = chartData.exchange2 || chartData.Exchange2 || "Ex2";
            
            // Log data for debugging
            if (!chartInstances.has(`${symbol}-${ex1}-${ex2}`)) {
                console.log("Received Chart Data:", chartData); 
            }

            const dashboard = document.getElementById('dashboard');
            // Use the robust variables
            const key = `${symbol}-${ex1}-${ex2}`;

            // Handle case where arrays might be PascalCase too
            const timestamps = chartData.timestamps || chartData.Timestamps || [];
            const spreads = chartData.spreads || chartData.Spreads || [];
            const upperBand = chartData.upperBand || chartData.UpperBand || [];
            const lowerBand = chartData.lowerBand || chartData.LowerBand || [];

            const dataForPlot = [
                timestamps,
                spreads,
                upperBand,
                lowerBand
            ];

            if (chartInstances.has(key)) {
                // Update existing chart
                const uplot = chartInstances.get(key);
                uplot.setData(dataForPlot);
            } else {
                // Create new chart
                const container = document.createElement('div');
                container.className = 'chart-container';
                container.id = key;

                const title = document.createElement('h2');
                title.textContent = `${symbol} (${ex1} / ${ex2})`;

                const chartWrapper = document.createElement('div');
                chartWrapper.className = 'chart-wrapper';

                container.appendChild(title);
                container.appendChild(chartWrapper);
                dashboard.appendChild(container);

                const uplot = renderChart(chartWrapper, dataForPlot);
                chartInstances.set(key, uplot);
            }
        }

        function closeActiveSocket() {
            if (activeSocket) {
                activeSocket.close();
                activeSocket = null;
                console.log("Previous WebSocket connection closed.");
            }
        }

        async function loadHttpStream(dataSourceUrl) {
            closeActiveSocket();
            const statusEl = document.getElementById('status');
            const dashboardEl = document.getElementById('dashboard');
            dashboardEl.innerHTML = ''; // Clear previous charts
            chartInstances.clear();
            let chartCount = 0;

            try {
                statusEl.textContent = `Connecting to data stream at ${dataSourceUrl}...`;
                const response = await fetch(dataSourceUrl);

                if (!response.ok) {
                    throw new Error(`Failed to fetch: ${response.status} ${response.statusText}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) {
                        if (buffer.trim()) {
                           const chartData = JSON.parse(buffer);
                           renderOrUpdateChart(chartData);
                           chartCount++;
                        }
                        break;
                    }

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop();

                    for (const line of lines) {
                        if (line.trim() === '') continue;
                        const chartData = JSON.parse(line);
                        renderOrUpdateChart(chartData);
                        chartCount++;
                        statusEl.textContent = `Rendered ${chartCount} charts...`;
                    }
                }

                if (chartCount === 0) {
                    statusEl.textContent = 'No data found meeting the criteria for this source.';
                } else {
                    statusEl.textContent = `Dashboard loaded with ${chartCount} charts.`;
                }

            } catch (error) {
                console.error('Error building dashboard from stream:', error);
                statusEl.innerHTML = `<p style="color: red;">Error: ${error.message}</p>`;
            }
        }

        function connectWebSocket() {
            closeActiveSocket();
            const statusEl = document.getElementById('status');
            const dashboardEl = document.getElementById('dashboard');
            dashboardEl.innerHTML = ''; // Clear previous charts
            chartInstances.clear();

            const socketUrl = "ws://127.0.0.1:5000/ws/realtime_charts";
            const socket = new WebSocket(socketUrl);
            activeSocket = socket;

            socket.onopen = () => {
                statusEl.textContent = "Real-time connection established. Waiting for data...";
            };

            socket.onmessage = (event) => {
                // Each message is a single chart update, not an array
                const chartData = JSON.parse(event.data);

                renderOrUpdateChart(chartData);

                statusEl.textContent = `Displaying ${chartInstances.size} real-time charts. Last update: ${new Date().toLocaleTimeString()}`;
            };

            socket.onerror = (error) => {
                console.error("WebSocket Error:", error);
                statusEl.innerHTML = `<p style="color: red;">WebSocket connection failed.</p>`;
            };

            socket.onclose = () => {
                statusEl.textContent = "Real-time connection closed.";
                activeSocket = null;
            };
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Data will now be loaded only on button click.
        });

        function renderChart(target, data) {
            const opts = {
                width: target.clientWidth,
                height: target.clientHeight,
                series: [
                    {}, // For timestamps
                    { // Spread
                        stroke: "rgba(80, 150, 255, 1)",
                        width: 1,
                        fill: "rgba(80, 150, 255, 0.1)",
                        label: "Spread"
                    },
                    { // Upper Band
                        stroke: "rgba(255, 100, 100, 0.8)",
                        width: 1,
                        dash: [10, 5],
                        label: "97th Percentile"
                    },
                    { // Lower Band
                        stroke: "rgba(100, 255, 100, 0.8)",
                        width: 1,
                        dash: [10, 5],
                        label: "3rd Percentile"
                    }
                ],
                axes: [
                    { show: false }, // Hide X axis
                    { stroke: '#888' }  // Style Y axis
                ],
                cursor: {
                    y: false, // Hide Y cursor line
                    x: false
                }
            };
            const uplot = new uPlot(opts, data, target);
            return uplot;
        }
    </script>
</body>
</html>
